[
    {
        "task_id": 0,
        "prompt": "\nQUESTION:\nA $\\mathbf{0}$-indexed array $a$ of size $n$ is called good if for all valid indices $i$ ($0 \\le i \\le n-1$), $a_i + i$ is a perfect square$^\\dagger$.\n\nGiven an integer $n$. Find a permutation$^\\ddagger$ $p$ of $[0,1,2,\\ldots,n-1]$ that is good or determine that no such permutation exists.\n\n$^\\dagger$ An integer $x$ is said to be a perfect square if there exists an integer $y$ such that $x = y^2$.\n\n$^\\ddagger$ An array $b$ is a permutation of an array $a$ if $b$ consists of the elements of $a$ in arbitrary order. For example, $[4,2,3,4]$ is a permutation of $[3,2,4,4]$ while $[1,2,2]$ is not a permutation of $[1,2,3]$.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n\nThe only line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the length of the permutation $p$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output $n$ distinct integers $p_0, p_1, \\dots, p_{n-1}$ ($0 \\le p_i \\le n-1$) \u2014 the permutation $p$ \u2014 if the answer exists, and $-1$ otherwise.\n\n\n-----Examples-----\n\nInput\n3\n3\n4\n7\nOutput\n1 0 2 \n0 3 2 1 \n1 0 2 6 5 4 3\n\n\n-----Note-----\n\nIn the first test case, we have $n=3$. The array $p = [1, 0, 2]$ is good since $1 + 0 = 1^2$, $0 + 1 = 1^2$, and $2 + 2 = 2^2$\n\nIn the second test case, we have $n=4$. The array $p = [0, 3, 2, 1]$ is good since $0 + 0 = 0^2$, $3 + 1 = 2^2$, $2+2 = 2^2$, and $1+3 = 2^2$.\nUse Standard Input format\nANSWER:\n",
        "output": [
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        sort(a.begin(), a.end());\n        for (int i = 0; i < n; i++) {\n            cout << a[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i];\n        }\n        sort(v.begin(), v.end());\n        for (int i = 0; i < n; i++) {\n            cout << v[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        if (n <= 2) {\n            cout << -1 << endl;\n            continue;\n        }\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] + i == 0) {\n                ans = i;\n                break;\n            }\n        }\n        if (ans == 0) {\n            cout << -1 << endl;\n            continue;\n        }\n        int b[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = a[i] - ans;\n        }\n        sort(b, b + n);\n        for (int i = 0; i < n; i++) {\n            cout << b[i] + ans << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
        ]
    },
    {
        "task_id": 1,
        "prompt": "\nQUESTION:\nKevin has a string S consisting of N lowercase English letters.  \n\nKevin wants to split it into 4 pairwise different non-empty parts.  For example, string \"happynewyear\" can be splitted into \"happy\", \"new\", \"ye\" and \"ar\". He can't delete any characters or change the order of the characters.\n\nHelp Kevin and find if there exist at least one possible spliting.\n\nInput format:\n\nThe first line of input will contain an integer T, denoting the number of test cases. Each of the next T lines contains a string S.\n\nOutput format:\n\nFor every test case output \"YES\" if it is possible to split the string and \"NO\" otherwise.\n\nConstraints:\n1 \u2264 T \u2264 100\n1 \u2264 N \u2264 1000\nN \u2264 20 in test data worth 40% of all points\n\nSAMPLE INPUT\n2\nababca\naaabb\n\nSAMPLE OUTPUT\nYES\nNO\nUse Standard Input format\nANSWER:\n",
        "output": [
            "import sys\nfor _ in range(int(sys.stdin.readline())):\n    s = sys.stdin.readline().strip()\n    if len(s) % 4!= 0:\n        print(\"NO\")\n        continue\n    for i in range(len(s) // 4):\n        if s[i * 4]!= s[i * 4 + 1] or s[i * 4]!= s[i * 4 + 2] or s[i * 4]!= s[i * 4 + 3]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n",
            "",
            ""
        ]
    },
    {
        "task_id": 2,
        "prompt": "\nQUESTION:\nComplete the method which accepts an array of integers, and returns one of the following:\n\n* `\"yes, ascending\"` - if the numbers in the array are sorted in an ascending order\n* `\"yes, descending\"` - if the numbers in the array are sorted in a descending order\n* `\"no\"` - otherwise\n\n\nYou can assume the array will always be valid, and there will always be one correct answer.def is_sorted_and_how(arr):\n\t\nUse Call-Based format\nANSWER:\n",
        "output": [
            "def is_sorted_and_how(arr):\n    if len(arr) < 2:\n        return \"yes, ascending\"\n    for i in range(1, len(arr)):\n        if arr[i - 1] > arr[i]:\n            return \"yes, descending\"\n    return \"no\"\n",
            "def is_sorted_and_how(arr):\n    if len(arr) == 1:\n        return \"yes, ascending\"\n    elif len(arr) == 2:\n        if arr[0] < arr[1]:\n            return \"yes, ascending\"\n        else:\n            return \"yes, descending\"\n    else:\n        if arr[0] < arr[1]:\n            return \"yes, ascending\"\n        else:\n            return \"yes, descending\"\n",
            "def is_sorted_and_how(arr):\n    if len(arr) == 1:\n        return \"yes, ascending\"\n    if len(arr) == 2:\n        if arr[0] < arr[1]:\n            return \"yes, ascending\"\n        else:\n            return \"yes, descending\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return \"yes, ascending\"\n        elif arr[i] > arr[i-1]:\n            return \"yes, descending\"\n    return \"no\"\n"
        ]
    },
    {
        "task_id": 3,
        "prompt": "\nQUESTION:\nYou are given a string and your task is to swap cases. In other words, convert all lowercase letters to uppercase letters and vice versa.\n\nFor Example:\n\nWww.HackerRank.com \u2192 wWW.hACKERrANK.COM\nPythonist 2 \u2192 pYTHONIST 2  \n\nFunction Description   \n\nComplete the swap_case function in the editor below.   \n\nswap_case has the following parameters:   \n\nstring s: the string to modify   \n\nReturns   \n\nstring: the modified string   \n\nInput Format\n\nA single line containing a string $\\boldsymbol{\\mathrm{~s~}}$.\n\nConstraints\n\n$0<len(s)\\leq1000$\n\nSample Input 0\nHackerRank.com presents \"Pythonist 2\".\n\nSample Output 0\nhACKERrANK.COM PRESENTS \"pYTHONIST 2\".\nUse Standard Input format\nANSWER:\n",
        "output": [
            "def swap_case(s):\n    return s.swapcase()\n",
            "def swap_case(s):\n    return s.swapcase()\n",
            "def swap_case(s):\n    return s.swapcase()\n"
        ]
    },
    {
        "task_id": 4,
        "prompt": "\nQUESTION:\nThere is a chessboard of size $n$ by $n$. The square in the $i$-th row from top and $j$-th column from the left is labelled $(i,j)$.\n\nCurrently, Gregor has some pawns in the $n$-th row. There are also enemy pawns in the $1$-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from $(i,j)$ to $(i-1,j)$) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $(i,j)$ to either $(i-1,j-1)$ or $(i-1,j+1)$) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\n\nGregor wants to know what is the maximum number of his pawns that can reach row $1$?\n\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row $1$, it is stuck and cannot make any further moves.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1\\le t\\le 2\\cdot 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nEach test case consists of three lines. The first line contains a single integer $n$ ($2\\le n\\le 2\\cdot{10}^{5}$) \u2014 the size of the chessboard.\n\nThe second line consists of a string of binary digits of length $n$, where a $1$ in the $i$-th position corresponds to an enemy pawn in the $i$-th cell from the left, and $0$ corresponds to an empty cell.\n\nThe third line consists of a string of binary digits of length $n$, where a $1$ in the $i$-th position corresponds to a Gregor's pawn in the $i$-th cell from the left, and $0$ corresponds to an empty cell.\n\nIt is guaranteed that the sum of $n$ across all test cases is less than $2\\cdot{10}^{5}$.\n\n\n-----Output-----\n\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the $1$-st row.\n\n\n-----Examples-----\n\nInput\n4\n3\n000\n111\n4\n1111\n1111\n3\n010\n010\n5\n11001\n00000\nOutput\n3\n4\n0\n0\n\n\n-----Note-----\n\nIn the first example, Gregor can simply advance all $3$ of his pawns forward. Thus, the answer is $3$.\n\nIn the second example, Gregor can guarantee that all $4$ of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\n\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\n\nIn the fourth example, Gregor has no pawns, so the answer is clearly $0$.\nUse Standard Input format\nANSWER:\n",
        "output": [
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s1, s2;\n        cin >> s1 >> s2;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (s1[i] == '1' && s2[i] == '0') {\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n",
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s1, s2;\n        cin >> s1 >> s2;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (s1[i] == '1' && s2[i] == '0') {\n                ans++;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n",
            "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s1, s2;\n        cin >> s1 >> s2;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (s1[i] == '1' && s2[i] == '0') {\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
        ]
    }
]